# Dependency Injection In Angular

## Основные понятия

**Dependency Injection** — шаблон проектирования, согласно которому происходит передача сервисов (хранилищ данных) к тем
или иным объектам (клиентам). Идея паттерна заключается в генерации требуемой зависимости и её последующей передаче клиенту.
Это позволяет эффективно использовать классы (модули) приложения, а также предотвращает побочные эффекты при замене зависимости.

Ядро Angular имеет собственную реализацию Dependency Injection (без этого было бы невозможно создать приложение).
Для внедрения сервиса его нужно зарегистрировать в объекте-поставщике (*провайдере*).

*Инжектор* отвечает за создание зависимостей, поддерживает контейнер экземпляров зависимостей и при необходимости использует их. При
создании экземпляров запрашиваемых сервисов инжектор полностью полагается на значения свойства *providers* или на значение объекта,
передаваемого декоратором @Injectable(). В процессе начальной загрузки создаются все требуемые для корректной работы приложения инжекторы.


## Способы регистрации сервиса

**1. В компоненте или директиве**
```
@Component({
    selector: 'app-home',
    templateUrl: './home.component.html',
    styleUrls: ['./home.component.scss'],
    providers: [SomeService]
})

@Directive({
    selector: 'appDirective',
    providers: [SomeService]
})
```

При каждой генерации компонента будет создаваться и внедряться новый экземпляр сервиса (при регистрации сервиса в компоненте
или директиве также генерируется дочерний инжектор; для разных компонентов и/или директив создаются разные инжекторы).

**2. В модуле**
```
@NgModule({
    providers: [SomeService]
})
```

Внутри модуля экземпляр сервиса создаётся единожды и внедряется в нужные компоненты (на уровне модулей все сервисы регистрируются корневым инжектором).

**3. В корне приложения**
```
@Injectable({
    providedIn: 'root'
})
export class SomeService {
    ...
}
```

Экземпляр сервиса создаётся единожды и является общим для всего приложения.


## Механизм поиска сервиса, иерархические декораторы
Когда компоненту (директиве) требуется сервис, то его поиск начинается с самого нижнего инжектора и далее вверх по иерархии, то есть сначала проверяется
уровень самого компонента (директивы). Если сервис был найден на одном из нижних уровней, то дальнейший поиск не осуществляется. Если же поиск
вообще не даст никаких результатов, то будет сгенерировано исключение. Этот механизм поиска можно переопределить с помощью иерархических декораторов.

* @Optional — при отсутствии требуемого сервиса не будет генерироваться исключение, а в переменную, которая должна была стать экземпляром, запишется null
* @Self — поиск требуемого сервиса будет осуществляться только на уровне текущего компонента (директивы)
* @SkipSelf — поиск требуемого сервиса будет осуществляться начиная с уровня выше относительно текущего компонента (директивы)
* @Host — поиск требуемого сервиса будет прекращён на уровне текущего компонента (директивы)


## Способы регистрации провайдера

Провайдер определяется *ключом*, по которому определена зависимость, и *рецептом*, по которому будет генерироваться зависимость
(также может быть третий параметр *multi: true*, позволяющий передавать по одному ключу *массив зависимостей*).

**1. useClass**

При каждом обращении к зависимости, указанной в provide, создаётся новый экземпляр класса, указанного в useClass
```
providers: [{provide: SomeService, useClass: SomeService}]
providers: [SomeService]    // эквивалент для предыдущей строки
{provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE]}
```

**2. useExisting**

При каждом обращении к зависимости, указанной в provide, используется один и тот же экземпляр класса, указанный в useExisting
```
providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => SelectWithFilterComponent),
      multi: true
    }
]
// forwardRef — функция-обёртка
```

**3. useValue**

Позволяет при обращении к зависимости, указанной в provide, использовать предопределённый объект
```
[
    ...
    {provide: MAT_DATE_LOCALE, useValue: 'ru-ru'},
    {provide: MAT_DATE_FORMATS, useValue: APP_DATE_FORMATS},
    ...
]

...
export declare const MAT_DATE_LOCALE: InjectionToken<string>;
export declare const MAT_DATE_FORMATS: InjectionToken<MatDateFormats>;
```

**4. useFactory**

Позволяет создавать переопределяющее значение в процессе работы приложения

```
// user.service.ts
constructor(private lastAuth: Date) {
    this.user.lastAuth = lastAuth;
}

// user-factory.service.ts
let userServiceFactory = (auth: AuthService) => {
    return new UserService(auth.lastAuthDate);
}

// app.module.ts
providers: [
  {
    provide: UserService,
    useFactory: userServiceFactory,
    deps: [AuthService]
  }
]
```


## Мультипровайдер
```
providers: [
    {
        provide: sToken,
        useValue: 'Пирожок',
        multi: true
    },
    {
        provide: sToken,
        useValue: 'Конфета',
        multi: true
    }
]

...
export class AppComponent implements OnInit {
    constructor(@Inject(sToken) private _multiProvider) {
    }

    ngOnInit() {
        console.log(this._multiProvider);   // ["Пирожок", "Конфета"]
    }  
}
```
